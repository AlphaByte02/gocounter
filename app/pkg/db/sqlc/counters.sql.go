// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: counters.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createCounter = `-- name: CreateCounter :one
INSERT INTO
  counters (id, user_id, name)
VALUES
  ($1, $2, $3)
RETURNING
  id, user_id, name, soft_reset, created_at, updated_at
`

type CreateCounterParams struct {
	ID     uuid.UUID  `json:"id"`
	UserID *uuid.UUID `json:"user_id"`
	Name   string     `json:"name"`
}

func (q *Queries) CreateCounter(ctx context.Context, arg CreateCounterParams) (Counter, error) {
	row := q.db.QueryRow(ctx, createCounter, arg.ID, arg.UserID, arg.Name)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.SoftReset,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCounter = `-- name: DeleteCounter :exec
DELETE FROM counters
WHERE
  id = $1
`

func (q *Queries) DeleteCounter(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCounter, id)
	return err
}

const getCounter = `-- name: GetCounter :one
SELECT
  id, user_id, name, soft_reset, created_at, updated_at
FROM
  counters
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetCounter(ctx context.Context, id uuid.UUID) (Counter, error) {
	row := q.db.QueryRow(ctx, getCounter, id)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.SoftReset,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCounterStats = `-- name: GetCounterStats :one
WITH
  Aggr AS (
    SELECT
      SUM(VALUE)       AS total,
      MIN(recorded_at) AS first_date
    FROM
      data
      JOIN counters ON data.counter_id = counters.id
    WHERE
      counter_id = $1
      AND recorded_at >= counters.soft_reset
  ),
  TimeCalc AS (
    SELECT
      total,
      first_date,
      CEIL(
        EXTRACT(
          epoch
          FROM
            (NOW() - first_date)
        ) / 86400.0
      ) AS days
    FROM
      Aggr
    WHERE
      first_date IS NOT NULL
  )
SELECT
  ct.total,
  ct.days,
  (ct.total / NULLIF(ct.days, 1))::float AS avg
FROM
  TimeCalc ct
`

type GetCounterStatsRow struct {
	Total int64   `json:"total"`
	Days  float64 `json:"days"`
	Avg   float64 `json:"avg"`
}

func (q *Queries) GetCounterStats(ctx context.Context, counterID uuid.UUID) (GetCounterStatsRow, error) {
	row := q.db.QueryRow(ctx, getCounterStats, counterID)
	var i GetCounterStatsRow
	err := row.Scan(&i.Total, &i.Days, &i.Avg)
	return i, err
}

const getCounterStatsGlobal = `-- name: GetCounterStatsGlobal :one
WITH
  Aggr AS (
    SELECT
      SUM(VALUE)       AS total,
      MIN(recorded_at) AS first_date
    FROM
      data
    WHERE
      counter_id = $1
  ),
  TimeCalc AS (
    SELECT
      total,
      first_date,
      CEIL(
        EXTRACT(
          epoch
          FROM
            (NOW() - first_date)
        ) / 86400.0
      ) AS days
    FROM
      Aggr
    WHERE
      first_date IS NOT NULL
  )
SELECT
  ct.total,
  ct.days,
  (ct.total / NULLIF(ct.days, 1))::float AS avg
FROM
  TimeCalc ct
`

type GetCounterStatsGlobalRow struct {
	Total int64   `json:"total"`
	Days  float64 `json:"days"`
	Avg   float64 `json:"avg"`
}

func (q *Queries) GetCounterStatsGlobal(ctx context.Context, counterID uuid.UUID) (GetCounterStatsGlobalRow, error) {
	row := q.db.QueryRow(ctx, getCounterStatsGlobal, counterID)
	var i GetCounterStatsGlobalRow
	err := row.Scan(&i.Total, &i.Days, &i.Avg)
	return i, err
}

const listCounters = `-- name: ListCounters :many
SELECT
  id, user_id, name, soft_reset, created_at, updated_at
FROM
  counters
ORDER BY
  id
`

func (q *Queries) ListCounters(ctx context.Context) ([]Counter, error) {
	rows, err := q.db.Query(ctx, listCounters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Counter
	for rows.Next() {
		var i Counter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.SoftReset,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountersByUser = `-- name: ListCountersByUser :many
SELECT
  id, user_id, name, soft_reset, created_at, updated_at
FROM
  counters
WHERE
  user_id = $1
ORDER BY
  id
`

func (q *Queries) ListCountersByUser(ctx context.Context, userID *uuid.UUID) ([]Counter, error) {
	rows, err := q.db.Query(ctx, listCountersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Counter
	for rows.Next() {
		var i Counter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.SoftReset,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCounter = `-- name: UpdateCounter :one
UPDATE counters
SET
  name = $2,
  user_id = $3
WHERE
  id = $1
RETURNING
  id, user_id, name, soft_reset, created_at, updated_at
`

type UpdateCounterParams struct {
	ID     uuid.UUID  `json:"id"`
	Name   string     `json:"name"`
	UserID *uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateCounter(ctx context.Context, arg UpdateCounterParams) (Counter, error) {
	row := q.db.QueryRow(ctx, updateCounter, arg.ID, arg.Name, arg.UserID)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.SoftReset,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
