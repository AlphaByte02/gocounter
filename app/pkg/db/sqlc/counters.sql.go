// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: counters.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCounter = `-- name: CreateCounter :one
INSERT INTO counters (
  id, user_id, name
) VALUES (
  $1, $2, $3
)
RETURNING id, user_id, name, soft_reset, created_at, updated_at
`

type CreateCounterParams struct {
	ID     uuid.UUID  `json:"id"`
	UserID *uuid.UUID `json:"user_id"`
	Name   string     `json:"name"`
}

func (q *Queries) CreateCounter(ctx context.Context, arg CreateCounterParams) (Counter, error) {
	row := q.db.QueryRow(ctx, createCounter, arg.ID, arg.UserID, arg.Name)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.SoftReset,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCounter = `-- name: DeleteCounter :exec
DELETE FROM counters WHERE id = $1
`

func (q *Queries) DeleteCounter(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCounter, id)
	return err
}

const getCounter = `-- name: GetCounter :one
SELECT id, user_id, name, soft_reset, created_at, updated_at FROM counters
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCounter(ctx context.Context, id uuid.UUID) (Counter, error) {
	row := q.db.QueryRow(ctx, getCounter, id)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.SoftReset,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCounterStats = `-- name: GetCounterStats :one
SELECT
    counter_id,
    SUM(value) AS total,
    MIN(recorded_at) AS firstDate,
    MAX(recorded_at) AS lastDate
FROM
    data
WHERE
    counter_id = $1
    AND recorded_at >= $2
GROUP BY
    counter_id
`

type GetCounterStatsParams struct {
	CounterID  uuid.UUID          `json:"counter_id"`
	RecordedAt pgtype.Timestamptz `json:"recorded_at"`
}

type GetCounterStatsRow struct {
	CounterID uuid.UUID   `json:"counter_id"`
	Total     int64       `json:"total"`
	Firstdate interface{} `json:"firstdate"`
	Lastdate  interface{} `json:"lastdate"`
}

func (q *Queries) GetCounterStats(ctx context.Context, arg GetCounterStatsParams) (GetCounterStatsRow, error) {
	row := q.db.QueryRow(ctx, getCounterStats, arg.CounterID, arg.RecordedAt)
	var i GetCounterStatsRow
	err := row.Scan(
		&i.CounterID,
		&i.Total,
		&i.Firstdate,
		&i.Lastdate,
	)
	return i, err
}

const listCounters = `-- name: ListCounters :many
SELECT id, user_id, name, soft_reset, created_at, updated_at FROM counters
ORDER BY id
`

func (q *Queries) ListCounters(ctx context.Context) ([]Counter, error) {
	rows, err := q.db.Query(ctx, listCounters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Counter
	for rows.Next() {
		var i Counter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.SoftReset,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountersByUser = `-- name: ListCountersByUser :many
SELECT id, user_id, name, soft_reset, created_at, updated_at FROM counters
WHERE user_id = $1
ORDER BY id
`

func (q *Queries) ListCountersByUser(ctx context.Context, userID *uuid.UUID) ([]Counter, error) {
	rows, err := q.db.Query(ctx, listCountersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Counter
	for rows.Next() {
		var i Counter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.SoftReset,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCounter = `-- name: UpdateCounter :one
UPDATE counters SET name = $2, user_id = $3 WHERE id = $1 RETURNING id, user_id, name, soft_reset, created_at, updated_at
`

type UpdateCounterParams struct {
	ID     uuid.UUID  `json:"id"`
	Name   string     `json:"name"`
	UserID *uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateCounter(ctx context.Context, arg UpdateCounterParams) (Counter, error) {
	row := q.db.QueryRow(ctx, updateCounter, arg.ID, arg.Name, arg.UserID)
	var i Counter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.SoftReset,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
